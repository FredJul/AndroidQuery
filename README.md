AndroidQuery
======================

AndroidQuery is an Android SQLite and ContentProvider ORM powered by an annotation preprocessor, tables are defined by @Table
annotations and CRUD classes expose an expressive api for executing SQLite queries.
####Gradle dependencies####
```groovy
dependencies {
    annotationProcessor 'net.frju.androidquery:android-query-preprocessor:1.2.2'
    compile 'net.frju.androidquery:android-query:1.2.2'
}
```

If you want to use RxJava you also need to add the following lines:
```groovy
    compile 'io.reactivex.rxjava2:rxjava:2.0.1'
    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'
```

####Initialize the ORM###
You need to initiale the ORM with a context to make it work properly. A good way to do it is by defining your Application object:
```java
public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        Q.init(this);
    }
}
```

And then declare it into your AndroidManifest.xml:
```xml
<application
        android:name=".App">
```

####Define your models###
You first need to declare your database. It can be a LocalDatabaseProvider (SQLite) or a ContentDatabaseProvider (ContentProvider) 
```java
public class LocalDatabaseProvider extends BaseLocalDatabaseProvider {

    public LocalDatabaseProvider(Context context) {
        super(context);
    }

    @Override
    protected String getDbName() {
        return "local_models";
    }

    @Override
    protected int getDbVersion() {
        return 1;
    }

    @Override
    protected Resolver getResolver() {
        return Q.getResolver();
    }

    @Override
    protected void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        super.onUpgrade(db, oldVersion, newVersion);

        // Put here your migration code
    }
}
```

Then tables are defined by POJOs that are annotated with `@Table`. Table columns are annotated with `@Column`.

```java
@Table(localDatabaseProvider = LocalDatabaseProvider.class)
public class User {
    @Column(index = true, realName = "_id", primaryKey = true, autoIncrement = true)
    public int id;
    @Column
    public String username;
    @Column
    public long timestamp;
    @Column
    public boolean isRegistered;
    @Column
    public byte[] profilePicture;
}
```

###Q###
The Q class is generated by the annotation preprocessor, it contains a bunch of method to easily query
your data and a series of static variables that can be used to reference @Table columns. As a good practise
these variables should be used whenever you reference a table column.

####Querying the database####
The `insert()`, `select()`, `update()`, `delete()`, `count()` and `raw()` methods are used to query the database tables.
The quey finishes by using either the `execute()` method or the `rx()` method.

The `rx()` method returns an RxJava Observable.

```java
Q.User.select()
        .rx()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer<Result<User>>() {
            @Override
            public void accept(Result<User> users) throws Exception {
    		// do something with the users
            }
        })
```

The `query()` method returns results directly. NOTE: `query()` will block the ui thread, 
we recommend you use RxJava.

```java
User user = new User();
user.setUsername("12345678");
user.setIsRegistered(true);
user.setTimestamp(System.currentTimeMillis());

// INSERT INTO User (username, isRegistered, timestamp) VALUES ('12345678',true,632348968244);
Q.User.insert(users).query();
```

```java
// SELECT * FROM User;
Result<User> users = Q.User.select().query();
...
users.close();
```

```java
ContentValues contentValues = new ContentValues();
contentValues.put(Q.User.IS_REGISTERED, true);
contentValues.put(Q.User.TIMESTAMP, System.currentTimeMillis());

// UPDATE User SET isRegistered = 'true', timestamp = '123456789'
int rowsUpdated = Q.User.update()
        .values(contentValues)
        .query();
```

```java
// DELETE FROM User;
int rowsDeleted = Q.User.delete().query();
```

```java
// SELECT Count(*) FROM User;
int count = Q.User.count().query();
```

####Clauses####
The `Where`, `And`, `In`, and `Or` classes are used to build up the query.
The following illustrate how to build more complex queries: 

```java
// SELECT * FROM User WHERE isRegistered = 'true';
Result<User> users = Q.User.select()
        .where(Condition.where(Q.User.IS_REGISTERED, Where.Op.IS, true))
        .query();
...
users.close();
```

```java
// SELECT * FROM User WHERE username LIKE 'jo%'
Result<User> users = Q.User.select()
        .where(Condition.where(Q.User.USERNAME, Where.Op.LIKE, "jo%"))
        .query();
...
users.close();
```

```java
// SELECT * FROM User WHERE username IN ("sam","josh");
Result<User> users = Q.User.select()
        .where(Condition.in(Q.User.USERNAME, "sam", "josh"))
        .query();
```

```java
// SELECT * FROM User WHERE ((username = "sam" OR username = "angie") AND (timestamp >= 1234567890));
Result<User> users = Q.User.select()
		.where(Condition.and(
                Condition.or(
                        Condition.where(Q.User.USERNAME, Where.Op.IS, "sam"),
                        Condition.where(Q.User.USERNAME, Where.Op.IS, "angie")
                ),
                Condition.and(
                        Condition.where(Q.User.TIMESTAMP, Where.Op.MORE_THAN_OR_EQUAL_TO, 1234567890)
                )))
        .query();
```

####Keywords####
The `OrderBy` and `Limit` classes are used to manipulate the results of the `select()` method

```java
// SELECT * FROM user ORDER BY username DESC
Result<User> users = Q.User.select()
        .orderBy(Q.User.USERNAME, OrderBy.Order.DESC)
        .query();
```

```java
// SELECT * FROM user ORDER BY username DESC LIMIT 2,4
Result<User> users = Q.User.select()
        .limit(2,4)
        .orderBy(Q.User.USERNAME, OrderBy.Order.DESC)
        .query();
```

####Joins####
Joins can be performed using the `InnerJoin`, `LeftOutJoin`, `CrossInnerJoin`, `NaturalInnerJoin`, `NaturalLeftOuterJoin` classes.
The target table for the join must be defined as an @Column, the object will be populated with any join results.

```java
@Table(localDatabaseProvider = LocalDatabaseProvider.class)
public class Comment {
    @Column(index = true) public int id;
    @Column public int userId;
    @Column public User user; // The target table for a potential join
}

@Table
@Table(localDatabaseProvider = LocalDatabaseProvider.class)
public class User {
    @Column(index = true) public int id;
}

Result<Comment> comments = Q.Comment.select()
                .join(innerJoin(User.class, Condition.on(Comment.class.getSimpleName() + '.' + Q.Comment.USER_ID, User.class.getSimpleName() + '.' + Q.User.ID)))
        .query();
        
User user = comments.toArray()[0].getUser(); // The nested User object is populated by the join
```

####TODO####
- Validate that object relationships defined by @Column are annotated with @Table
- Validate that auto_increment columns must be int or long
- @Table annotation should support foreign_key functionality
- @NotNull annotation and handle this validation in the software layer
- Composite Foreign Key Constraints
