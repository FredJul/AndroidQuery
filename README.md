SQLKing
======================

SQLKing is an Android SQLite ORM powered by an annotation preprocessor, tables are defined by Model
classes and CRUD classes expose an expressive api for executing SQLite queries.
####Gradle dependency####
```groovy
dependencies {
    apt 'com.memtrip.sqlking:sqlking-preprocessor:1.0'
    compile 'com.memtrip.sqlking:sqlking-client:1.0'
}
```

####Define your models###
SQL tables are defined by POJOs that are annotated with `@Table`. The getter and setter methods must
match the member variables, i.e; `private String name;` must be accompanied by
`getName()` / `setName(String newVal)` methods.

```java
@Table
public class User {
    @Member private String username;
    @Member private long timestamp;
    @Member private boolean isRegistered;
    @Member private byte[] profilePicture;

    public String getUsername() {
        return username;
    }

    public void setUsername(String newVal) {
        username = newVal;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long newVal) {
        timestamp = newVal;
    }

    public boolean getIsRegistered() {
        return isRegistered;
    }

    public void setIsRegistered(boolean newVal) {
        isRegistered = newVal;
    }

    public byte[] getProfilePicture() {
        return profilePicture;
    }

    public void setProfilePicture(byte[] newVal) {
        profilePicture = newVal;
    }
}
```

###Q###
The Q class is generated by the annotation preprocessor, it contains a DefaultResolver() method
which is required by SQLInit to create the database. Q also contains a series of static variables
that can be used to reference @Table columns. As a good practise these variables should be used
whenever you reference a table column.

```java
// an example of columns that are auto generated within a Q class
public static final String USERNAME = "username";
public static final String TIMESTAMP = "timestamp";
public static final String IS_REGISTERED = "isRegistered";
public static final String PROFILE_PICTURE = "profilePicture";

// the columns can be accessed directly from the Q class, e.g;
String usernameColumnFromUserTable = Q.User.USERNAME;
```

####Initialise the database####
SQLKing will create a database based on the POJOs that are annotated with @Table,
when these POJOs are changed or new POJOs are added, the version number argument must be incremented.
NOTE: Incrementing the version number will drop and recreate the database.

```java
public void setUp() {
    SQLProvider provider = SQLInit.createDatabase(
         "SQLKing",
         1,
         new Q.DefaultResolver(),
         mContext,
         User.class,
         Post.class
    );
}
```

####Querying the database####
The `Insert`, `Select`, `Update`, `Delete` and `Count` classes are used to query database tables,
they use a `getBuilder()` method to add clause and operation arguments. The Builder finishes by
using either the `execute()` method or the `rx()` method.

The `rx()` method returns an RxJava Observable.

```java
Select.getBuilder()
    .rx(User.class, sqlProvider)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Action1<User[]>() {
        @Override
        public void call(User[] users) {
            // do something with the users
        }
    });
```

```java
User user = new User();
user.setUsername("12345678");
user.setIsRegistered(true);
user.setTimestamp(System.currentTimeMillis());

// INSERT INTO User (username, isRegistered, timestamp) VALUES ('12345678',true,632348968244);
Insert.getBuilder().values(users).execute(User.class, sqlProvider);
```

```java
// SELECT * FROM User;
User[] users = Select.getBuilder().execute(User.class, sqlProvider);
```

```java
ContentValues contentValues = new ContentValues();
contentValues.put(Q.User.IS_REGISTERED, true);
contentValues.put(Q.User.TIMESTAMP, System.currentTimeMillis());

// UPDATE User SET isRegistered = 'true', timestamp = '123456789'
Update.getBuilder()
        .values(contentValues)
        .execute(User.class, getSQLProvider());
```

```java
// DELETE FROM User;
User[] users = Delete.getBuilder().execute(User.class, sqlProvider);
```

```java
// SELECT Count(*) FROM User;
long count = Count.getBuilder().execute(User.class, sqlProvider);
```

####Clauses####
The `Where`, `And`, `In`, and `Or` classes are used to build up the query.
`Where` is powered by the `Exp`ression enum:

```java
public enum Exp {
	EQUAL_TO ("="),
	MORE_THAN (">"),
	MORE_THAN_OR_EQUAL_TO (">="),
	LESS_THAN ("<"),
	LESS_THAN_OR_EQUAL_TO ("<="),
	LIKE ("LIKE");
}
``` 

The following illustrate how to build more complex queries: 

```java
// SELECT * FROM User WHERE isRegistered = 'true';
User[] users = Select.getBuilder()
        .where(new Where(Q.User.IS_REGISTERED, Where.Exp.EQUAL_TO, true))
        .execute(User.class, sqlProvider);
```

```java
// SELECT * FROM User WHERE username LIKE 'jo%'
User[] users = Select.getBuilder()
        .where(new Where(Q.User.USERNAME, Where.Exp.LIKE, "jo%"))
        .execute(User.class, sqlProvider);
```

```java
// SELECT * FROM User WHERE username IN ("sam","josh");
User[] users = Select.getBuilder()
        .where(new In(Q.User.USERNAME, "sam", "josh"))
        .execute(User.class, sqlProvider);
```

```java
// SELECT * FROM User WHERE ((username = "sam" OR username = "angie") AND (timestamp >= 1234567890));
User[] users = Select.getBuilder()
		.where(new And(
                new Or(
                        new Where(Q.User.USERNAME, Where.Exp.EQUAL_TO, "sam"),
                        new Where(Q.User.USERNAME, Where.Exp.EQUAL_TO, "angie")
                ),
                new And(
                        new Where(Q.User.TIMESTAMP, Where.Exp.MORE_THAN_OR_EQUAL_TO, 1234567890)
                )))
        .execute(User.class, sqlProvider);
```

####Keywords####
The `OrderBy` and `Limit` classes are used to manipulate the results of the `SELECT` class

```java
// SELECT * FROM user ORDER BY username DESC
User[] users = Select.getBuilder()
        .orderBy(Q.User.USERNAME, OrderBy.Order.DESC)
        .execute(User.class, sqlProvider);
```

```java
// SELECT * FROM user ORDER BY username DESC LIMIT 2,4
User[] users = Select.getBuilder()
        .limit(2,4)
        .orderBy(Q.User.USERNAME, OrderBy.Order.DESC)
        .execute(User.class, sqlProvider);
```

####Tests####
The `tests/java/com/memtrip/sqlking` package contains a full set of unit and integration tests. The
tests can be used as a good reference on how to structure queries.

####TODO####
- Add the Random() method to OrderBy
- Execute CREATE INDEX queries for @Member annotations that use an index
- Implement the @Member annotation foreign_key functionality